# 管道的属性（匿名管道）
* 半双工通讯
* 管道有两个部分 读端 和 写端 分别对应两个文件描述符
* 本质上就是一块内核上的缓冲区，是一种伪文件，可以将其当作文件操作（write, read...）
* 管道的生命周期为从  创建管道操作开始， 直至操作管道的进程结束，结束后管道会被被自动释放  
* 该缓冲区的大小默认是 4K，但会根据实际情况进行扩充（实测最大为64K，Ubuntu，pipe_size_test.c）
* 缓冲区内的数据只能被读取一次，读取完后就被删除（新数据覆盖）
* 只能用于具有血缘关系的进程间的通讯

创建管道
 ```    
    ...
    int fd[2];
    pipe(fd);  
    //pipe()成功返回两个文件描述符，fd[0]为读端， fd[1]为写端，失败返回 -1.
    ...
 ```
___
## 管道的读写
>*在默认情况下管道的读写两端均是阻塞的，那么如何设置使其变为非阻塞呢？*

读操作
* **当管道内有数据的时候：** 
    * 对于读操作而言，能够正常读取数据，不会发生阻塞的情况 

* **当管道内没有数据的时候：**
  * 分为两种情况：
    *  当父子进程的写端被全部关闭，则此时读操作不会被阻塞，返回0，相当于读到了文件的尾部  
    *  当父子进程中有写端未被关闭，此时读操作会被阻塞 

 
写操作
* **父子进程的读端部被关闭的时候：**
  * 发生管道破裂，进程被终止， 同时内核会向当前进程发送SIGPIPE信号
* 父子进程中还有读端未关闭的时候：
  * 当此时缓冲区已满
    * 写操作被阻塞，直至（管道有数据被读走）有空闲区产生，再继续执行写操作
  * 当此时缓冲区未满
    * 写操作正常向管道中写入数据 
___


## 设置非阻塞方法
* 设置读端为非阻塞
  * 使用  fcntl()  函数，修改管道读端文件描述符对应文件的属性
    * 通过获取原来的flag后对其进行修改即可
    ```
        ...
        int flag = fcntl(fd[0], F_GETFL);
        fcntl(fd[0], F_SETFL, flag | O_NONBLOCK);
        ...
    ```
____

# 有名管道FIFO

* 实质上是一种特殊类型的文件，可以通过ls命令查看到
* 也是一种伪文件(open, write, read...)， 在磁盘中的大小始终为0
* 实际操作时数据被放在内核中的一块缓冲区上
* 突破了匿名管道的局限，可以在没有血缘关系的进程间通讯


## 创建FIFO
1. 函数创建
```

int mkfifo(FIFO, mode);

fd = open(FIFO, O_RDONLY);
    read(fd...)
    close(fd)

fd = open(FIFO, O_WRONLY)
    write(fd...)
    close(fd)
```
2. 命令行指令创建    mkfifo FIFO